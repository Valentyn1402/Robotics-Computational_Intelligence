#!/usr/bin/env python3

from controller import Controller
from motor.msg import MotorPWM
from get_position import MazeListener
import sys 
import os
import numpy as np
import rospy
import time
from maze_solver.main import get_path
from pathlib import Path
import os

if __name__ == "__main__":

    #initialize rospy node
    rospy.init_node("controller_node", anonymous=True)

    #create a publisher node to the /motor/pwm_cmd topic
    pub = rospy.Publisher("/motor/pwm_cmd", MotorPWM, 
                          queue_size=10) 
    rospy.loginfo("Publisher created: /motor/pwm_cmd")

    #retrieve the path generated by get_path()
    tags = Path("/home/jetson/Downloads/tags.yaml")
    path = get_path(tags, (0, 0), (3, 1))
    print("path received")
    new_path = [np.array([point[1], point[0]]) for point in path]

    print(path)

    print(new_path)

    #falls import nicht funktioniert einfach selber path definieren 
    #create a path 
    #path = np.array([[0.131, 0.195], [0.131, 0.445], [0.131, 0.695], [0.445, 0.695], [0.445, 0.945]])

    #create controller instance 
    controller = Controller(new_path, theta=0)
    print("initialized Controller instance \n")

    #set the initial robot position as start point 
    controller.pos = new_path[0]

    # #set previous coordinates 
    # prev_cord = np.zeroes(2)

    # # print("The angle of the robot is: ", listener.get_rotation())

    #go through each coordinate in the new_path (in order)
    for index, coordinate in enumerate(new_path):

        print(coordinate)
        if index == len(new_path) - 1:
            controller.epsilon = 0.1
        #make sure that the node is still running 
        if rospy.is_shutdown():
            break
        else: 
            print("Going towards following cordinate:" + " in x: " + str(coordinate[0]) \
            + " in y: " + str(coordinate[1]))
            #for each point check if the distance between the middle point of the
            #chassis is close enough to the coordinate, if not run the control loop
            while np.linalg.norm(controller.pos - coordinate) > controller.epsilon: 
                print("still driving towards following cordinate:" + " in x: " + str(coordinate[0]) + " in y: " + str(coordinate[1]))
                if rospy.is_shutdown():
                    break
                print("The angle of the robot is: " + str(controller.theta))
                controller.regelung(controller.pos, coordinate)
                #update self position
                controller.pos[0] += controller.v*np.cos(controller.theta)*controller.dt
                controller.pos[1] += controller.v*np.sin(controller.theta)*controller.dt  
                print("Robot: position is: " + " in x: " + str(controller.pos[0]) + " in y: " + str(controller.pos[1]))

                time.sleep(controller.dt)
