#!/usr/bin/env python3

from controller import Controller
from motor.msg import MotorPWM
from get_position import MazeListener
import sys 
import os
import numpy as np
import rospy
import time
from maze_solver.main import get_path
from pathlib import Path
import os

#if __name__ == "__main__":
#    print(os.getcwd())
#    #retrieve the path generated by get_path()
#    tags = Path("/home/jetson/Downloads/tags.yaml")
#    path = get_path(tags, (0, 0), (0, 3))
#    print(f"path received: {path}")

def estimate_position(prev_cord: np.array, controller: Controller, maze: MazeListener):
    if maze.get_position() is None:
        position[0] = prev_cord[0] + controller.v*np.cos(controller.theta)*controller.dt
        position[1] = prev_cord[1] + controller.v*np.sin(controller.theta)*controller.dt
        return position
    else:
        position = maze.get_position()
        return position[0:2]


if __name__ == "__main__":

    #initialize rospy node
    rospy.init_node("controller_node", anonymous=True)

    #create a publisher node to the /motor/pwm_cmd topic
    pub = rospy.Publisher("/motor/pwm_cmd", MotorPWM, queue_size=10) 
    rospy.loginfo("Publisher created: /motor/pwm_cmd")

    #retrieve the path generated by get_path()
    tags = Path("/home/jetson/Downloads/tags.yaml")
    path = get_path(tags, (0, 0), (3, 3))
    print("path received")
    new_path = [np.array([point[1], point[0]]) for point in path]

    print(path)

    print(new_path)

    #falls import nicht funktioniert einfach selber path definieren 
    #create a path 
    #path = np.array([[0.131, 0.195], [0.131, 0.445], [0.131, 0.695], [0.445, 0.695], [0.445, 0.945]])
    #print("initialized path array \n")

    #create mazelistener instance 
    listener = MazeListener()
    print("created MazeListener instance")

    #get the angle through terminal

    theta = input("Give the angle position of robot: ")
    print(theta)

    #create controller instance 
    controller = Controller(new_path, theta=float(theta))
    print("initialized Controller instance \n")

    #set the initial robot position as start point 
    robot_position = new_path[0]

    #set previous coordinates 
    prev_cord = np.zeros(2)

    # print("The angle of the robot is: ", listener.get_rotation())

    #go through each coordinate in the new_path (in order)
    for index, coordinate in enumerate(new_path):

        print(coordinate)
        if index == len(new_path) - 1:
            controller.epsilon = 0.1
        #make sure that the node is still running 
        if rospy.is_shutdown():
            break
        else: 
            print("Going towards following cordinate:" + " in x: " + str(coordinate[0]) \
            + " in y: " + str(coordinate[1]))
            #for each point check if the distance between the middle point of the
            #chassis is close enough to the coordinate, if not run the control loop
            while True: 
                print("still driving towards following cordinate:" + " in x: " + str(coordinate[0]) + " in y: " + str(coordinate[1]))
                robot_pos = estimate_position(prev_cord, controller, listener)
                if rospy.is_shutdown():
                    break
                elif np.linalg.norm(robot_pos - coordinate) <= controller.epsilon:
                    break
                else:
                    print("The angle of the robot is: " + str(controller.theta))
                    controller.regelung(robot_position[0:2], coordinate)
                    controller.pos[0] = robot_pos[0]
                    controller.pos[1] = robot_pos[1]    
                    prev_cord = robot_pos
                    print("Robot: position is: " + " in x: " + str(robot_position[0]) + " in y: " + str(robot_position[1]))

                time.sleep(controller.dt)
