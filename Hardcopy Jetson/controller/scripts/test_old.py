#!/usr/bin/env python3

from controller import Controller
from motor.msg import MotorPWM
from get_position import MazeListener
import sys 
import os
import numpy as np
import rospy
import time
from maze_solver.main import get_path
from pathlib import Path
import os

#if __name__ == "__main__":
#    print(os.getcwd())
#    #retrieve the path generated by get_path()
#    tags = Path("/home/jetson/Downloads/tags.yaml")
#    path = get_path(tags, (0, 0), (0, 3))
#    print(f"path received: {path}")

if __name__ == "__main__":

    #initialize rospy node
    rospy.init_node("controller_node", anonymous=True)

    #create a publisher node to the /motor/pwm_cmd topic
    pub = rospy.Publisher("/motor/pwm_cmd", MotorPWM, queue_size=10) 
    rospy.loginfo("Publisher created: /motor/pwm_cmd")

    #retrieve the path generated by get_path()
    tags = Path("/home/jetson/Downloads/tags.yaml")
    path = get_path(tags, (0, 0), (3, 3))
    print("path received")
    new_path = [np.array([point[1], point[0]]) for point in path]

    print(path)

    print(new_path)


    #falls import nicht funktioniert einfach selber path definieren 
    #create a path 
    #path = np.array([[0.131, 0.195], [0.131, 0.445], [0.131, 0.695], [0.445, 0.695], [0.445, 0.945]])
    #print("initialized path array \n")

    #create mazelistener instance 
    listener = MazeListener()
    print("created MazeListener instance")

    #create controller instance 
    controller = Controller(new_path, theta=0)
    print("initialized Controller instance \n")

    #set the initial robot position as start point 
    robot_position = new_path[0]

    # print("The angle of the robot is: ", listener.get_rotation())

    #go through each coordinate in the new_path (in order)
    for index, coordinate in enumerate(new_path):

        print(coordinate)
        if index == len(new_path) - 1:
            controller.epsilon = 0.1
        #make sure that the node is still running 
        if rospy.is_shutdown():
            break
        else: 
            print("Going towards following cordinate:" + " in x: " + str(coordinate[0]) \
            + " in y: " + str(coordinate[1]))
            #for each point check if the distance between the middle point of the
            #chassis is close enough to the coordinate, if not run the control loop
            while np.linalg.norm(robot_position[0:2] - coordinate) > controller.epsilon: 
                print("still driving towards following cordinate:" + " in x: " + str(coordinate[0]) + " in y: " + str(coordinate[1]))
                if rospy.is_shutdown():
                    break
                print("The angle of the robot is: " + str(controller.theta))
                controller.regelung(robot_position[0:2], coordinate)
                if listener.get_position() is not None:
                    robot_position[0] = listener.get_position()[0]
                    robot_position[1] = listener.get_position()[1]
                    # robot_position[0] = listener.get_position()[0]
                    # robot_position[1] = listener.get_position()[1]

                    controller.pos[0] = listener.get_position()[0]
                    controller.pos[1] = listener.get_position()[1]

                    # if listener.get_rotation() is not None:
                    #     controller.theta += listener.get_rotation()*controller.dt
                    #     print("Current robot angle: ",controller.theta)
                    # controller.pos[0] = listener.get_position()[0]
                    # controller.pos[1] = listener.get_position()[1]

                    print("Robot: position is: " + " in x: " + str(robot_position[0]) + " in y: " + str(robot_position[1]))

                time.sleep(controller.dt)
